// Copyright 2024 Vladimir Kochnev. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file is generated by mkmach.go

package mach

import "unsafe"

var libc_mach_vm_allocate_trampoline_addr uintptr

//go:cgo_import_dynamic libc_mach_vm_allocate mach_vm_allocate "/usr/lib/libSystem.B.dylib"

func mach_vm_allocate(target vm_map_t, address *uintptr, size uint, flags int32) error {
	args := struct {
		target  uintptr
		address uintptr
		size    uintptr
		flags   uintptr
	}{
		target:  uintptr(target),
		address: uintptr(unsafe.Pointer(address)),
		size:    uintptr(size),
		flags:   uintptr(flags),
	}
	if ret := libcCall(unsafe.Pointer(libc_mach_vm_allocate_trampoline_addr), unsafe.Pointer(&args)); ret != 0 {
		return kern_return_err(ret)
	}
	return nil
}

var libc_mach_vm_deallocate_trampoline_addr uintptr

//go:cgo_import_dynamic libc_mach_vm_deallocate mach_vm_deallocate "/usr/lib/libSystem.B.dylib"

func Mach_vm_deallocate(target vm_map_t, address uintptr, size uint) error {
	args := struct {
		target  uintptr
		address uintptr
		size    uintptr
	}{
		target:  uintptr(target),
		address: uintptr(address),
		size:    uintptr(size),
	}
	if ret := libcCall(unsafe.Pointer(libc_mach_vm_deallocate_trampoline_addr), unsafe.Pointer(&args)); ret != 0 {
		return kern_return_err(ret)
	}
	return nil
}

var libc_mach_vm_remap_trampoline_addr uintptr

//go:cgo_import_dynamic libc_mach_vm_remap mach_vm_remap "/usr/lib/libSystem.B.dylib"

func mach_vm_remap(target_task vm_map_t, target_address *uintptr, size uint, mask uint, flags int32, src_task vm_map_t, src_address uintptr, copy bool, cur_protection *vm_prot_t, max_protection *vm_prot_t, inheritance vm_inherit_t) error {
	args := struct {
		target_task    uintptr
		target_address uintptr
		size           uintptr
		mask           uintptr
		flags          uintptr
		src_task       uintptr
		src_address    uintptr
		copy           uintptr
		cur_protection uintptr
		max_protection uintptr
		inheritance    uintptr
	}{
		target_task:    uintptr(target_task),
		target_address: uintptr(unsafe.Pointer(target_address)),
		size:           uintptr(size),
		mask:           uintptr(mask),
		flags:          uintptr(flags),
		src_task:       uintptr(src_task),
		src_address:    uintptr(src_address),
		copy:           uintptr(boolUint8(copy)),
		cur_protection: uintptr(unsafe.Pointer(cur_protection)),
		max_protection: uintptr(unsafe.Pointer(max_protection)),
		inheritance:    uintptr(inheritance),
	}
	if ret := libcCall(unsafe.Pointer(libc_mach_vm_remap_trampoline_addr), unsafe.Pointer(&args)); ret != 0 {
		return kern_return_err(ret)
	}
	return nil
}
