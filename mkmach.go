// Copyright 2024 Vladimir Kochnev. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore

package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	regexpSig = regexp.MustCompile(`^([a-zA-Z][a-z0-9_]*)\(([^)]+)\)( ([a-z_]+))?`)
	regexpArg = regexp.MustCompile(`([a-z][a-z0-9_]*) (\*?[a-z][a-z0-9_]*)`)
)

type funcArg struct {
	name string
	typ  string
	ptr  bool
}

type funcDesc struct {
	sig      string
	name     string
	args     []funcArg
	ret      string
	nonblock bool
}

func main() {
	dir, err := os.Getwd()
	if err != nil {
		die(err)
	}
	dirEntries, err := os.ReadDir(dir)
	if err != nil {
		die(err)
	}
	for _, dirEntry := range dirEntries {
		if !dirEntry.Type().IsRegular() {
			continue
		}
		basePath := filepath.Base(dirEntry.Name())
		if !strings.HasPrefix(basePath, "mach_") {
			continue
		}
		baseName, ok := strings.CutSuffix(basePath, ".go")
		if !ok {
			continue
		}
		if strings.HasSuffix(baseName, "_test") {
			continue
		}
		file, err := os.Open(dirEntry.Name())
		if err != nil {
			die(err)
		}
		defer file.Close()

		var funcs []funcDesc
		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			var fun funcDesc
			line := scanner.Text()
			if sig, ok := strings.CutPrefix(line, "//mach\t"); ok {
				fun.sig = sig
			} else if sig, ok := strings.CutPrefix(line, "//machnb\t"); ok {
				fun.sig = sig
				fun.nonblock = true
			} else {
				continue
			}
			submatches := regexpSig.FindStringSubmatch(fun.sig)
			if submatches == nil {
				dief("Invalid signature %q\n", fun.sig)
			}
			fun.name = strings.ToLower(submatches[1])
			fun.ret = submatches[4]
			switch fun.ret {
			case "error", "string", "":
			default:
				dief("Unsupported function return type %q\n", fun.ret)
			}
			for _, argStr := range strings.Split(submatches[2], ", ") {
				submatches := regexpArg.FindStringSubmatch(argStr)
				if submatches == nil {
					dief("Invalid argument string %q\n", argStr)
				}
				arg := funcArg{name: submatches[1]}
				if typ, ok := strings.CutPrefix(submatches[2], "*"); ok {
					arg.typ = typ
					arg.ptr = true
				} else {
					arg.typ = submatches[2]
				}
				fun.args = append(fun.args, arg)
			}
			funcs = append(funcs, fun)
		}
		mkStubs(filepath.Join(dir, "z"+baseName+".go"), funcs)
		mkAMD64Trampolines(filepath.Join(dir, "z"+baseName+"_amd64.s"), funcs)
		mkARM64Trampolines(filepath.Join(dir, "z"+baseName+"_arm64.s"), funcs)
	}
}

func (arg funcArg) is32() bool {
	if arg.ptr {
		return false
	}
	switch arg.typ {
	case "int32", "uint32", "mach_error_t", "vm_map_t":
		return true
	default:
		return false
	}
}

func mkStubs(filePath string, funcs []funcDesc) {
	fmt.Println("Writing", filePath)
	file, err := os.Create(filePath)
	if err != nil {
		die(err)
	}
	defer file.Close()

	writeHeader(file)
	file.WriteString("// This file is generated by mkmach.go\n\n")

	file.WriteString("package mach\n\nimport \"unsafe\"\n\n")
	for j, fun := range funcs {
		if j > 0 {
			file.WriteString("\n")
		}
		isret64 := strings.HasPrefix(fun.ret, "*") || fun.ret == "string"
		fmt.Fprintf(file, "var libc_%s_trampoline_addr uintptr\n\n", fun.name)
		fmt.Fprintf(file, "//go:cgo_import_dynamic libc_%s %s \"/usr/lib/libSystem.B.dylib\"\n\n", fun.name, fun.name)
		fmt.Fprintf(file, "func %s {\n", fun.sig)
		file.WriteString("\targs := struct {\n")
		for _, arg := range fun.args {
			fmt.Fprintf(file, "\t\t%s uintptr\n", arg.name)
		}
		if isret64 {
			file.WriteString("\t\tret uintptr\n")
		}
		file.WriteString("\t}{\n")
		for _, arg := range fun.args {
			switch {
			case arg.ptr:
				fmt.Fprintf(file, "\t\t%s: uintptr(unsafe.Pointer(%s)),\n", arg.name, arg.name)
			case arg.typ == "string":
				fmt.Fprintf(file, "\t\t%s: uintptr(unsafe.Pointer(makeCString(%s))),\n", arg.name, arg.name)
			case arg.typ == "bool":
				fmt.Fprintf(file, "\t\t%s: uintptr(boolUint8(%s)),\n", arg.name, arg.name)
			default:
				fmt.Fprintf(file, "\t\t%s: uintptr(%s),\n", arg.name, arg.name)
			}
		}
		file.WriteString("\t}\n")
		if isret64 {
			fmt.Fprintf(file, "\tlibcCall(unsafe.Pointer(libc_%s_trampoline_addr), unsafe.Pointer(&args))\n", fun.name)
			switch fun.ret {
			case "string":
				file.WriteString("\treturn makeStringFromCString((*byte)(unsafe.Pointer(args.ret)))\n")
			default:
				fmt.Fprintf(file, "\treturn %s(args.ret)\n", fun.ret)
			}
		} else if fun.ret == "error" {
			fmt.Fprintf(file, "\tif ret := libcCall(unsafe.Pointer(libc_%s_trampoline_addr), unsafe.Pointer(&args)); ret != 0 {\n", fun.name)
			fmt.Fprintf(file, "\t\treturn kern_return_err(ret)\n")
			fmt.Fprintf(file, "\t}\n")
			fmt.Fprintf(file, "\treturn nil\n")
		} else if fun.ret != "" {
			fmt.Fprintf(file, "\treturn %s(libcCall(unsafe.Pointer(libc_%s_trampoline_addr), unsafe.Pointer(&args)))\n", fun.ret, fun.name)
		} else {
			fmt.Fprintf(file, "\tlibcCall(unsafe.Pointer(libc_%s_trampoline_addr), unsafe.Pointer(&args))\n", fun.name)
		}
		file.WriteString("}\n")
	}
}

func mkAMD64Trampolines(filePath string, funcs []funcDesc) {
	fmt.Println("Writing", filePath)
	file, err := os.Create(filePath)
	if err != nil {
		die(err)
	}
	defer file.Close()
	writeHeader(file)
	file.WriteString("// This file is generated by mkmach.go\n\n")
	file.WriteString("#include \"textflag.h\"\n\n")
	for j, fun := range funcs {
		if j > 0 {
			file.WriteString("\n")
		}
		fmt.Fprintf(file, "TEXT\tlibc_%s_trampoline<>(SB),NOSPLIT,$0\n", fun.name)
		var regArgs, stackArgs []funcArg
		if len(fun.args) <= 6 {
			regArgs = fun.args
		} else {
			regArgs = fun.args[:6]
			stackArgs = fun.args[6:]
		}
		isret64 := strings.HasPrefix(fun.ret, "*") || fun.ret == "string"

		if isret64 {
			file.WriteString("\tPUSHQ\tDI\n")
		}

		if len(regArgs) > 0 {
			for i, arg := range regArgs[1:] {
				i += 1
				var reg string
				switch i {
				case 1:
					reg = "SI"
				case 2:
					reg = "DX"
				case 3:
					reg = "CX"
				case 4:
					reg = "R8"
				case 5:
					reg = "R9"
				}
				if !arg.is32() {
					fmt.Fprintf(file, "\tMOVQ\t%v(DI), %s\t// %s\n", i*8, reg, arg.name)
				} else {
					fmt.Fprintf(file, "\tMOVL\t%v(DI), %s\t// %s\n", i*8, reg, arg.name)
				}
			}
		}
		var stackAdj int
		if len(stackArgs) > 0 {
			if len(stackArgs)%2 != 0 {
				stackAdj = 8 + len(stackArgs)*8
				file.WriteString("\tADJSP\t$8\n")
			} else {
				stackAdj = len(stackArgs) * 8
			}
			for i := range stackArgs {
				i = len(stackArgs) - i - 1
				arg := stackArgs[i]
				fmt.Fprintf(file, "\tPUSHQ\t%v(DI)\t\t// %s\n", (6+i)*8, arg.name)
			}
		}
		if len(regArgs) > 0 {
			if !regArgs[0].is32() {
				fmt.Fprintf(file, "\tMOVQ\t0(DI), DI\t// %s\n", regArgs[0].name)
			} else {
				fmt.Fprintf(file, "\tMOVL\t0(DI), DI\t// %s\n", regArgs[0].name)
			}
		}
		fmt.Fprintf(file, "\tCALL\tlibc_%s(SB)\n", fun.name)
		if len(stackArgs) > 0 {
			fmt.Fprintf(file, "\tADJSP\t$-%v\n", stackAdj)
		}
		if isret64 {
			file.WriteString("\tPOPQ\tDI\n")
			fmt.Fprintf(file, "\tMOVQ\tAX, %v(DI)\n", len(fun.args)*8)
		}
		file.WriteString("\tRET\n\n")

		fmt.Fprintf(file, "GLOBL\t路libc_%s_trampoline_addr(SB), RODATA, $8\n", fun.name)
		fmt.Fprintf(file, "DATA\t路libc_%s_trampoline_addr(SB)/8, $libc_%s_trampoline<>(SB)\n", fun.name, fun.name)
	}
}

func mkARM64Trampolines(filePath string, funcs []funcDesc) {
	fmt.Println("Writing", filePath)
	file, err := os.Create(filePath)
	if err != nil {
		die(err)
	}
	defer file.Close()
	writeHeader(file)
	file.WriteString("// This file is generated by mkmach.go\n\n")
	file.WriteString("#include \"textflag.h\"\n\n")
	for j, fun := range funcs {
		if j > 0 {
			file.WriteString("\n")
		}
		fmt.Fprintf(file, "TEXT\tlibc_%s_trampoline<>(SB),NOSPLIT,$0\n", fun.name)
		var regArgs, stackArgs []funcArg
		if len(fun.args) <= 8 {
			regArgs = fun.args
		} else {
			regArgs = fun.args[:8]
			stackArgs = fun.args[8:]
		}
		isret64 := strings.HasPrefix(fun.ret, "*") || fun.ret == "string"

		var (
			stackAdj        int
			stackArgsOffset int
		)
		if isret64 {
			stackAdj += 8
		}
		stackArgsOffset = stackAdj
		stackAdj += len(stackArgs) * 8
		if stackAdj%16 != 0 {
			stackAdj += 8
		}
		if stackAdj > 0 {
			fmt.Fprintf(file, "\tSUB\t$%v, RSP\n", stackAdj)
		}
		if isret64 {
			file.WriteString("\tMOVD\tR0, 0(RSP)\n")
		}
		for i := range stackArgs {
			arg := stackArgs[i]
			fmt.Fprintf(file, "\tMOVD\t%v(R0), R1\n", (8+i)*8)
			fmt.Fprintf(file, "\tMOVD\tR1, %v(RSP)\t// %s\n", stackArgsOffset+i*8, arg.name)
		}

		if len(regArgs) > 0 {
			for i, arg := range regArgs[1:] {
				i += 1
				var reg string
				switch i {
				case 1:
					reg = "R1"
				case 2:
					reg = "R2"
				case 3:
					reg = "R3"
				case 4:
					reg = "R4"
				case 5:
					reg = "R5"
				case 6:
					reg = "R6"
				case 7:
					reg = "R7"
				}
				if !arg.is32() {
					fmt.Fprintf(file, "\tMOVD\t%v(R0), %s\t// %s\n", i*8, reg, arg.name)
				} else {
					fmt.Fprintf(file, "\tMOVW\t%v(R0), %s\t// %s\n", i*8, reg, arg.name)
				}
			}
		}
		if len(regArgs) > 0 {
			if !regArgs[0].is32() {
				fmt.Fprintf(file, "\tMOVD\t0(R0), R0\t// %s\n", regArgs[0].name)
			} else {
				fmt.Fprintf(file, "\tMOVW\t0(R0), R0\t// %s\n", regArgs[0].name)
			}
		}
		fmt.Fprintf(file, "\tBL\tlibc_%s(SB)\n", fun.name)
		if isret64 {
			file.WriteString( "\tMOVD\t0(RSP), R1\n")
			fmt.Fprintf(file, "\tMOVD\tR0, %v(R1)\n", len(fun.args)*8)
		}
		if stackAdj > 0 {
			fmt.Fprintf(file, "\tADD\t$%v, RSP\n", stackAdj)
		}
		file.WriteString("\tRET\n\n")

		fmt.Fprintf(file, "GLOBL\t路libc_%s_trampoline_addr(SB), RODATA, $8\n", fun.name)
		fmt.Fprintf(file, "DATA\t路libc_%s_trampoline_addr(SB)/8, $libc_%s_trampoline<>(SB)\n", fun.name, fun.name)
	}
}

func writeHeader(file *os.File) {
	file.WriteString("// Copyright 2024 Vladimir Kochnev. All rights reserved.\n")
	file.WriteString("// Use of this source code is governed by a BSD-style\n")
	file.WriteString("// license that can be found in the LICENSE file.\n\n")
}

func die(a ...any) {
	fmt.Fprintln(os.Stderr, a...)
	os.Exit(1)
}

func dief(format string, a ...any) {
	fmt.Fprintf(os.Stderr, format, a...)
	os.Exit(1)
}
